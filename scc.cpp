#include <vector>
#include <iostream>
#include <queue>
#include <algorithm>
using namespace std;
//---------------------------------------------------------------------------------------------

vector<vector<int>> node;
vector<int> num,s, low;
vector<bool> vis;
int cntCh = 0;
int numSCC = 0;

void SCC(int u) {
	num[u] = low[u] = ++cntCh;				// заполняем время захода
	s.push_back(u);							// наполняем стэк
	vis[u] = 1;								// делаем вершину доступной для вхождения в другие компоненты
	for (auto v : node[u])					// перебираем все исходящие вершины
	{
		if (num[v] == 0) SCC(v);			// если вершина v ещё не исследована, то запускаемся от неё
		if (vis[v]) low[u] = std::min(low[u], low[v]); // если вершина не часть другой компоненты, то делаем её частью текущей
	}
	if (num[u] == low[u]) {					// начальная вершина компоненты связности
		//cout << ++numSCC << ": ";
        ++numSCC;
		while (1)							// вытаскиваем из стэка вершина, которые являются частью комп. связности вершины u
		{
			int v = s.back(); s.pop_back(); vis[v] = 0;	// помечаем вершину как частью уже другой компоненты
			//cout << v << " ";
			if (u == v) break;				// как только дошли обратно до вершины u, то все нужные вершины уже часть компоненты.
		}
		//cout << "\n";
	}
}
